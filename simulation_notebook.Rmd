---
title: "Point Process Simulation"
output: pdf_document
---

```{r echo=FALSE}
suppressMessages(library(MASS))
suppressMessages(library(dplyr))
knitr::opts_chunk$set(echo = FALSE, cache = T)
```
```{r}
gammaShRaFromMeanSD = function( mean , sd ) {
  if ( mean <=0 ) stop("mean must be > 0")
  if ( sd <=0 ) stop("sd must be > 0")
  shape = mean^2/sd^2
  rate = mean/sd^2
  return( list( shape=shape , rate=rate ) )
}
```



# Proposed Model
$\alpha_{jk} \sim Gamma(\bar{a}_{\alpha}, \bar{b}_{\alpha})$



# Estimated Parameters
```{r}
ad_types <- c("search", "display", "other", "purchase")
K <- length(ad_types)
alpha_mean <- matrix(c(2.817, 0.0860, 0.5381, 0.6167,
                      0.1614, 1.7818, 0.2055, 0.0845,
                      0.4647, 0.1270, 8.0526, 0.8384), nrow = 3, ncol = 4)
row.names(alpha_mean) <- ad_types[1:3]
colnames(alpha_mean) <- ad_types

alpha_sd <- matrix(c(0.1765, 0.0214, 0.0562, 0.0633,
                      0.0496, 0.2314, 0.0572, 0.0347,
                      0.0654, 0.0367, 0.4117, 0.0867), nrow = 3, ncol = 4)

beta_mean <- c(34.0188, 46.8854, 51.5114)
beta_sd <- c(1.7426, 4.9370, 2.3241)
names(beta_mean) <- ad_types[1:3]

theta_mu_mean <- c(-5.3926, -6.1027, -5.8063, -9.7704) 
theta_mu_sd <- c(0.0166, 0.0212, 0.0221, 0.0762) 
names(theta_mu_mean) <- ad_types
names(theta_mu_sd) <- ad_types

Sigma_mu_mean <- matrix(c(0.4584, -0.1197, -0.4942, 0.2256,
                     -0.1197, 0.5934, -0.3380, -0.4157,
                     -0.4942, -0.3380, 1.0014, 0.0762,
                     0.2256, -0.4157, 0.0762, 2.3914), nrow = 4, ncol = 4)

Sigma_mu_sd <- matrix(c(0.0246, -0.0212, 0.0257, 0.1228,
                     0.0212, 0.0335, 0.0304, 0.1665,
                     0.0257, 0.0304, 0.0365, 0.2440,
                     0.1228, 0.1665, 0.2440, 0.2575), nrow = 4, ncol = 4)

row.names(Sigma_mu_mean) <- ad_types
colnames(Sigma_mu_mean) <- ad_types
  
psi_mean <- c(-0.5664, -0.7556, -0.6235, 0.2787)
psi_sd <- c(0.1228, 0.2348, 0.1229, 0.2160)
names(psi_mean) <- ad_types
names(psi_sd) <- ad_types
```

```{r results = 'asis'}
knitr::kable(alpha_mean, caption = "alpha", escape = F)
```

```{r results = 'asis'}
knitr::kable(beta_mean, caption = "beta", escape = F)
```

```{r results = 'asis'}
knitr::kable(theta_mu_mean, caption = "theta", escape = F)
```

```{r results = 'asis'}
knitr::kable(Sigma_mu_mean, caption = "Sigma", escape = F)
```

```{r results = 'asis'}
knitr::kable(psi_mean, caption = "psi", escape = F)
```

# Simulate Data

## Draw Parameters
1. Draw $\alpha, \beta, \psi, \theta_{\mu}, \Sigma_{\mu}$ and generate $\mu^i \sim MVN_K(\theta_{\mu}, \Sigma_{\mu})$ to simulate the behaviour of a representative customer.
```{r}
alpha <- matrix(nrow = nrow(alpha_mean), ncol = ncol(alpha_mean))
for(j in c(1:nrow(alpha_mean))) {
  for(k in c(1:ncol(alpha_mean))) {
    gam <- gammaShRaFromMeanSD(mean = alpha_mean[j,k], sd = alpha_sd[j,k])
    alpha[j,k] <- rgamma(n=1, shape = gam$shape, rate = gam$rate)
  }
}

beta <- numeric()
for(j in c(1:length(beta_mean))) {
    gam <- gammaShRaFromMeanSD(mean = beta_mean[j], sd = beta_sd[j])
    beta[j] <- rgamma(n=1, shape = gam$shape, rate = gam$rate)
}

##### Use means until we found a way to create distributions to draw from! #####
# psi <- psi_mean
# TODO: check if we can use diagonal of sd here 
psi <- mvrnorm(mu = psi_mean, Sigma = psi_sd * diag(nrow = length(psi_sd)))
# theta_mu <- theta_mu_mean
# TODO: check if we can use diagonal of sd here 
theta_mu <-mvrnorm(mu = theta_mu_mean, Sigma = theta_mu_sd * diag(nrow = length(theta_mu_sd)))
# TODO: Check how to draw from IW dist. using mean and sd
Sigma_mu <- Sigma_mu_mean
```
Draw $\mu^i \sim log\text{-}MVN_K(\theta_{\mu}, \Sigma_{\mu})$
```{r}
mu <- exp(mvrnorm(mu = theta_mu, Sigma = Sigma_mu))
```
2. Simulate point process in $[0,T]$ given $\alpha, \beta, \psi, \mu^i$ and realized type $j_0$ at $t_0=0 \text{,} (j_0 = 1, \dots, K-1)$.
```{r}
j_0 <- sample(length(ad_types) - 1, size = 1)
# TODO: check if t's unit is actually in days
T <- 120
```
    $j_0$ is set to type "`r ad_types[j_0]`" with $T=$ `r T`.

    a. initialize $t = 0, n = 0, n_K = 0, m = \sum_{k=1}^K (\mu^i_k+\alpha_{j_ok})$
```{r}
t = 0; n = 0; n_K = 0; m = c(alpha[j_0,] + mu) %>% sum; j = integer(); t_j = numeric()
```
    b. Repeat until $t>T$
        (i) Simulate $s \sim Exp(m)$
        (ii) Set $t = t + s$
        (iii) Calculate $\lambda$ and $m$
      
```{r}
#sprintf("Initially set m to %f", m)
hist_intensity_decay <- function(a, b, events, current_time, event_times) {
  result <- numeric(K)
  names(result) <- ad_types
  if(length(events) == 0) return(result)
  
  for(k in 1:K){
    for(idx in 1:length(events)){
      j_l <- events[idx]
      if(j_l != K) { # do not consider purchases (K) here
        result[k] <- result[k] + alpha[j_l, k] * exp(-1 * beta[j_l] * (t - event_times[idx]))
      }
    }
  }
  return(result)
}

repeat {
  s <- rexp(n = 1, rate = m)
  t <- t + s
  #sprintf("t is %f", t)
  if(!is.nan(t) && t < T){
    lambda <- mu * exp(psi*n_K) + alpha[j_0, ] * exp(-1 * beta[j_0] * t)
    lambda <- lambda + hist_intensity_decay(alpha, beta, j, t, t_j)
    U <- runif(n = 1)
    if(U <= sum(lambda) / m){
      #print("Create new event")
      n <- n + 1
      t_j[n] <- t
      j[n] <- which(rmultinom(n = 1, size = 1, prob = lambda/sum(lambda))[,1] %in% c(1)) # choose next click event
      if(j[n] == K) { # if purchase
        n_K <- n_K + 1
        m <- sum(lambda - mu * exp(psi * (n_K -1)) + mu * exp(psi * n_K))
        #sprintf("Set m to %f for purchase", m)
      } else {
        m <- sum(lambda + alpha[j[n], ])
        #sprintf("Set m to %f for non-purchase", m)
      }
    } else {
      #sprintf("No event created. U is %f", U)
      m <- sum(lambda)
      #sprintf("Set m to %f for no new event", m)
    }
  }
  
  if(t > T) break
}
```

